<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analisador de Loot Log do Albion</title>
    <!-- Carrega o Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Tema Escuro Padrão (Baseado no ShadCN) */
        :root {
            color-scheme: dark;
        }

        body {
            font-family: 'Inter', sans-serif;
            /* Cor de fundo principal (ShadCN background) */
            background-color: #030712; /* slate-950 */
            /* Cor de texto principal (ShadCN foreground) */
            color: #f8fafc; /* slate-50 */
        }

        /* Remove os estilos customizados de .file-input-button e .dark-select */
        /* Todo o estilo será feito com classes do Tailwind no HTML */
        
        /* Estilo para Tooltips (dicas) (Atualizado para o tema ShadCN) */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            /* Fundo (ShadCN Popover) */
            background-color: #030712; /* slate-950 */
            color: #f8fafc; /* slate-50 */
            text-align: left;
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.5rem; /* p-2 */
            position: absolute;
            z-index: 10;
            bottom: 125%; /* Posiciona acima do ícone */
            left: 50%;
            margin-left: -100px; /* Metade da largura para centralizar */
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            border: 1px solid #1e293b; /* slate-800 */
            font-size: 0.75rem; /* text-xs */
            line-height: 1.4;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Elementos de Interface Modernos */
        select, input, button, a {
            transition: all 0.3s ease;
        }

        /* Efeito hover padrão para botões e links */
        button:hover, a:hover {
            opacity: 0.9;
        }

        /* Efeito simples para imagens de itens */
        .tooltip img {
            display: block;
            transition: opacity 0.2s ease;
        }

        .tooltip:hover img {
            opacity: 0.9;
        }

        /* Estilo moderno para selects */
        select {
            background-color: #1e293b; /* slate-800 */
            border: 1px solid #475569; /* slate-600 */
        }

        select:hover, select:focus {
            border-color: #94a3b8; /* slate-400 */
            background-color: #334155; /* slate-700 */
        }

        /* Efeito de hover suave para cards */
        .card-hover-effect {
            transition: transform 0.2s ease;
        }

        .card-hover-effect:hover {
            transform: translateY(-1px);
        }

    </style>
    <!-- Fonte Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="p-4 md:p-8">
    
    <div class="max-w-7xl mx-auto space-y-8">

        <!-- Mensagens de Status (Loading, Erro, Sucesso) -->
        <!-- Estilo (Alert) do ShadCN -->
        <div id="loading" class="hidden p-4 text-blue-300 bg-slate-900 border border-blue-700 rounded-lg">
            <h5 class="font-medium">Processando</h5>
            <p class="text-sm text-blue-400" id="loading-message">Processando, por favor aguarde...</p>
        </div>
        <div id="error" class="hidden p-4 text-red-400 bg-slate-900 border border-red-700 rounded-lg">
            <h5 class="font-medium">Erro</h5>
            <p class="text-sm text-red-500" id="error-message"></p>
        </div>
        <div id="success" class="hidden p-4 text-green-400 bg-slate-900 border border-green-700 rounded-lg">
             <h5 class="font-medium">Sucesso</h5>
            <p class="text-sm text-green-500" id="success-message"></p>
        </div>

        <!-- Seção de Upload de Arquivos (Estilo Card) -->
        <div class="bg-slate-900 border border-slate-800 rounded-lg shadow-sm">
            <div class="p-6">
                <h3 class="text-lg font-medium mb-4">Carregar Arquivos</h3>
                <!-- Atualizado para 2 colunas -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Passo 1: Log de Loot -->
                    <div>
                        <label for="lootLogInput" class="inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors h-10 px-4 py-2 bg-slate-800 text-slate-50 hover:bg-slate-800/80 cursor-pointer w-full">
                            1. Carregar Log(s) de Loot (.csv) (suporta múltiplos)
                        </label>
                        <input type="file" id="lootLogInput" class="hidden" accept=".csv,.txt" multiple>
                        <div class="mt-2 ml-1 flex items-center gap-2">
                            <p id="lootLogStatus" class="text-sm text-slate-400"></p>
                            <button id="clearLootButton" class="text-sm px-2 py-1 rounded-md bg-slate-800 text-slate-200 hover:bg-slate-700">Limpar</button>
                        </div>
                    </div>

                    <!-- Passo 2: Log do Baú (Renomeado) -->
                    <div>
                        <label for="chestLogInput" id="chestLogLabel" class="inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors h-10 px-4 py-2 bg-slate-800 text-slate-50 hover:bg-slate-800/80 cursor-pointer w-full opacity-50" style="cursor: not-allowed;">
                            2. Carregar Log do Baú (.csv / .txt)
                        </label>
                        <input type="file" id="chestLogInput" class="hidden" accept=".csv,.txt" disabled>
                        <p id="chestLogStatus" class="text-sm text-slate-400 mt-2 ml-1"></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Seção de Sumário -->
        <section id="summarySection" class="hidden bg-slate-900 border border-slate-800 rounded-lg shadow-sm">
            <div class="p-6">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-medium">Sumário do Loot</h3>
                    <div id="itemsSummary" class="text-sm px-3 py-1 bg-slate-800 rounded-md text-slate-200"></div>
                </div>
                <div class="space-y-4">
                    <!-- Maior Looter -->
                    <div class="flex items-center space-x-2">
                        <div class="flex-shrink-0">
                            <div class="w-12 h-12 bg-slate-800 rounded-full flex items-center justify-center">
                                <svg class="w-6 h-6 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                                </svg>
                            </div>
                        </div>
                        <div class="flex-grow">
                            <h4 class="text-sm font-medium text-slate-400">Maior Looter</h4>
                            <p id="topLooterSummary" class="text-base font-semibold text-slate-200"></p>
                        </div>
                    </div>

                    <!-- Guild Looter -->
                    <div class="flex items-center space-x-2">
                        <div class="flex-shrink-0">
                            <div class="w-12 h-12 bg-slate-800 rounded-full flex items-center justify-center">
                                <svg class="w-6 h-6 text-emerald-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path>
                                </svg>
                            </div>
                        </div>
                        <div class="flex-grow">
                            <h4 class="text-sm font-medium text-slate-400">Guild com Mais Loot</h4>
                            <p id="topGuildSummary" class="text-base font-semibold text-slate-200"></p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Seção de Filtros (Estilo Card) -->
        <section id="filtersSection" class="hidden bg-slate-900 border border-slate-800 rounded-lg shadow-sm">
            <div class="p-6 flex flex-col md:flex-row md:items-center md:space-x-6 space-y-4 md:space-y-0">
                <!-- Filtro de Guilda (Estilo Input/Select) -->
                <div class="flex-1">
                    <label for="guildFilter" class="block text-sm font-medium text-slate-300 mb-2">Filtrar por Guilda:</label>
                    <select id="guildFilter" name="guildFilter" class="flex h-10 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-slate-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950">
                        <option value="all">Todas as Guildas</option>
                        <!-- Opções de guilda serão preenchidas dinamicamente -->
                    </select>
                </div>
                
                <!-- Filtro de Depósito (Estilo Input/Select) -->
                <div id="depositFilterContainer" class="flex-1 hidden">
                    <label for="depositFilter" class="block text-sm font-medium text-slate-300 mb-2">Filtrar por Depósito:</label>
                    <select id="depositFilter" name="depositFilter" class="flex h-10 w-full rounded-md border border-slate-700 bg-slate-950 px-3 py-2 text-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-slate-500 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950">
                        <option value="all">Todos os Itens</option>
                        <option value="deposited">Apenas Depositados (parcial ou total)</option>
                        <option value="not-deposited">Apenas Não Depositados</option>
                        <option value="lost">Itens Perdidos</option>
                    </select>
                </div>
            </div>
        </section>

        <!-- Seção de Resultados -->
        <section id="resultsSection" class="space-y-6">
            
            <!-- Card de Estatísticas da Guilda (Estilo Card) -->
            <div id="guildStatsCard" class="bg-slate-900 border border-slate-800 rounded-lg shadow-sm overflow-hidden hidden">
                <!-- CardHeader -->
                <div class="p-6 border-b border-slate-800">
                    <h2 id="guildStatsTitle" class="text-xl font-semibold tracking-tight text-white">
                        Estatísticas da Guilda
                    </h2>
                </div>
                <!-- CardContent -->
                <div id="guildStatsItems" class="p-6 flex flex-wrap gap-3">
                    <!-- Ícones dos itens da guilda serão inseridos aqui -->
                </div>
            </div>

            <!-- Container dos Cards de Jogador -->
            <div id="playerLootContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- 
                Template de Card de Jogador (Estilo Card)
                <div class="bg-slate-900 border border-slate-800 rounded-lg shadow-sm overflow-hidden">
                    <div class="p-4 border-b border-slate-800 flex justify-between items-center">
                        <div>
                            <h3 class="text-lg font-semibold tracking-tight">Nome do Jogador</h3>
                            <p class="text-sm text-slate-400">[Nome da Guilda]</p>
                        </div>
                        <a href="#" target="_blank" rel="noopener noreferrer" class="inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors h-9 px-3 py-1 bg-transparent text-slate-50 hover:bg-slate-800 hover:text-slate-50">
                            Murderledger
                        </a>
                    </div>
                    <div class="p-4 flex flex-wrap gap-3">
                        (Ícones aqui)
                    </div>
                </div> 
                -->
            </div>
        </section>

    </div>

    <script type="module">
        // --- Variáveis Globais de Estado ---
    let lootData = {}; // Guarda o loot principal
        let chestDepositData = {}; // Guarda os depósitos do baú
        let itemTranslationMap = {}; // Guarda o "dicionário" (ex: "nome ptbr normalizado": "id_base_normalizado")
        let guildList = new Set(); // Lista de guildas únicas
        let isItemMapReady = false; // Flag para saber se o items.json foi carregado
    let lootEntrySet = new Set(); // Set de chaves únicas para evitar duplicação entre múltiplos logs

        // --- Variáveis Globais da DOM ---
        // (Declaradas aqui, inicializadas no DOMContentLoaded)
        let lootLogInput, lootLogStatus, 
            chestLogInput, chestLogLabel, chestLogStatus,
            guildFilter, depositFilter, depositFilterContainer, filtersSection,
            loading, loadingMsg, errorEl, successEl, errorElMsg, successElMsg,
            guildStatsCard, guildStatsTitle,
            guildStatsItems, playerLootContainer;
        let clearLootButton;


        // --- FUNÇÕES DE LÓGICA E PARSING ---
        // (As definições das funções ficam no escopo do módulo)

        /**
         * Carrega e processa o items.json da URL.
         */
        async function loadItemsJsonFromUrl() {
            try {
                showLoading("Baixando dicionário de itens (items.json)...");
                const response = await fetch('https://loot-logger-albion.vercel.app/items.json');
                
                if (!response.ok) {
                    throw new Error(`Erro HTTP! status: ${response.status}`);
                }
                
                const jsonText = await response.text(); // Ler como texto primeiro
                const items = JSON.parse(jsonText); // Fazer o parse
                
                itemTranslationMap = buildItemTranslationMap(items);
                isItemMapReady = true;

                showSuccess(`Dicionário de itens carregado! ${Object.keys(itemTranslationMap).length} itens mapeados.`);
                resetUI('items'); // Habilita o Passo 2 (Baú) se o Passo 1 já estiver pronto
            
            } catch (err) {
                showError(`Falha ao carregar items.json da URL: ${err.message}. Tente recarregar a página.`);
                console.error("Stack:", err.stack);
                isItemMapReady = false;
                resetUI(null); // Reseta tudo
            }
        }
        
        /**
         * Processa o CSV do Log de Loot (Passo 1).
         * @param {string} csvText - O conteúdo do arquivo CSV.
         * @returns {Object} - Objeto com { data: lootByPlayer, guilds: guildList }
         */
        function parseLootLog(csvText, existingEntrySet = new Set()) {
            const lootByPlayer = {}; // Estrutura: { playerKey: { name, guild, items: { itemKey: { ... } } } }
            const guildList = new Set();
            let entriesAdded = 0;
            let duplicateEntries = 0;
            let totalEntries = 0;
            
            // Remove BOM e corrige quebras de linha
            const lines = csvText.trim().replace(/^\uFEFF/, '').split(/\r?\n/);

            if (lines.length <= 1) {
                throw new Error("O arquivo CSV está vazio ou tem apenas cabeçalhos.");
            }

            // Limpa cabeçalhos (remove aspas, espaços e BOM residual)
            const headers = lines[0].trim().replace(/^\uFEFF/, '').split(';').map(h => h.replace(/"/g, '').trim());
            
            // Encontra os índices das colunas necessárias
            const nameIndex = headers.indexOf('looted_by__name');
            const guildIndex = headers.indexOf('looted_by__guild');
            const itemIdIndex = headers.indexOf('item_id');
            const itemNameIndex = headers.indexOf('item_name');
            const quantityIndex = headers.indexOf('quantity');
            
            // Tenta detectar coluna de timestamp (se existir) para ajudar a compor chave única
            const timestampIndex = headers.findIndex(h => ['time','timestamp','date','created_at','looted_at'].includes(h.toLowerCase()));

            // Validação dos cabeçalhos
            if ([nameIndex, guildIndex, itemIdIndex, itemNameIndex, quantityIndex].includes(-1)) {
                console.error("Cabeçalhos encontrados:", headers);
                throw new Error("Cabeçalhos do CSV não encontrados: 'looted_by__name', 'looted_by__guild', 'item_id', 'item_name' ou 'quantity' estão faltando.");
            }

            // Itera pelas linhas de dados
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line) continue; // Pula linhas em branco

                const columns = line.split(';');

                // Pega os dados das colunas
                const playerName = columns[nameIndex]?.replace(/"/g, '').trim();
                const playerGuild = columns[guildIndex]?.replace(/"/g, '').trim() || 'Sem Guilda'; // Padrão se a guilda estiver vazia
                const itemId = columns[itemIdIndex]?.replace(/"/g, '').trim(); // Ex: T7_2H_MACE@1
                const itemName = columns[itemNameIndex]?.replace(/"/g, '').trim(); // Ex: Grandmaster's Heavy Mace
                const quantity = parseInt(columns[quantityIndex], 10);
                const timestamp = timestampIndex >= 0 ? (columns[timestampIndex] || '').replace(/"/g,'').trim() : '';

                // Validação da linha
                if (!playerName || !itemId || !itemName || isNaN(quantity) || quantity <= 0) {
                    continue; // Pula linhas inválidas ou que não sejam loot (ex: quantidade 0)
                }

                // Ignora itens do tipo "Trash" (T2_TRASH, T3_TRASH, etc)
                // e também ignora "Combat Memento" (por nome ou por ID)
                const itemIdUpper = (itemId || '').toUpperCase();
                const itemNameLower = (itemName || '').toLowerCase();
                if (itemIdUpper.includes('_TRASH') || itemIdUpper.includes('MEMENTO') || itemNameLower.includes('combat memento') || itemNameLower.includes('memento')) {
                    // Pula itens classificados como lixo ou mementos de combate
                    continue;
                }
                
                // --- Checagem de duplicidade por entrada ---
                // Chave composta: player normalizado | itemId completo | itemName normalizado | quantity | timestamp(optional)
                const entryKey = `${normalizeString(playerName)}|${itemId}|${normalizeString(itemName)}|${quantity}|${timestamp}`;
                totalEntries++;
                if (existingEntrySet.has(entryKey)) {
                    // Já processado em outro log
                    duplicateEntries++;
                    continue;
                }
                // Marca como existente para evitar duplicatas futuras
                existingEntrySet.add(entryKey);
                entriesAdded++;

                // --- Normalização ---
                // Chave do jogador (ex: "ogrenred")
                const playerKey = normalizeString(playerName);
                
                // Chave do item (ex: "t7_2h_mace")
                // Remove encantamento (@1) e qualidade para agrupar
                const uniqueName = itemId.split('@')[0]; // Ex: T7_2H_MACE
                const itemKey = normalizeString(uniqueName); // Ex: t7_2h_mace

                // Adiciona guilda à lista
                guildList.add(playerGuild);

                // Inicializa o jogador se for a primeira vez
                if (!lootByPlayer[playerKey]) {
                    lootByPlayer[playerKey] = {
                        name: playerName,
                        guild: playerGuild,
                        items: {}
                    };
                }
                
                // Inicializa o item para o jogador se for a primeira vez
                if (!lootByPlayer[playerKey].items[itemKey]) {
                    lootByPlayer[playerKey].items[itemKey] = {
                        name: itemName, // Nome em Inglês (do log de loot)
                        itemId: itemId, // ID completo (com @) para o ícone
                        uniqueName: uniqueName, // ID base (sem @)
                        lootedQuantity: 0,
                        depositedQuantity: 0, // Inicia zerado
                        history: [], // Histórico de loots
                        lostItem: false // Flag para itens perdidos
                    };
                }
                
                // Adiciona entrada ao histórico
                lootByPlayer[playerKey].items[itemKey].history.push({
                    timestamp: timestamp || new Date().toISOString(),
                    player: playerName,
                    guild: playerGuild,
                    quantity: quantity
                });
                
                // Soma a quantidade looteada
                lootByPlayer[playerKey].items[itemKey].lootedQuantity += quantity;
            }
            
            if (Object.keys(lootByPlayer).length === 0) {
                // Se nenhum dado novo foi adicionado, retornamos erro específico
                if (entriesAdded === 0) {
                    throw new Error("Nenhum dado de loot válido ou novo foi encontrado no arquivo (talvez duplicado).");
                }
                throw new Error("Nenhum dado de loot válido foi encontrado no arquivo.");
            }

            return { 
                data: lootByPlayer, 
                guilds: guildList, 
                entriesAdded,
                duplicateEntries,
                totalEntries 
            };
        }

        /**
         * Processa o JSON de Itens (Passo 2).
         * Cria um mapa de "Nome PT-BR Normalizado" -> "ID Base Normalizado".
         * @param {Array} items - O array de itens do items.json.
         * @returns {Object} - Mapa (dicionário) de tradução.
         */
        function buildItemTranslationMap(items) {
            const translationMap = {};

            if (!Array.isArray(items)) {
                throw new Error("O arquivo items.json não é um array válido.");
            }

            items.forEach(item => {
                // Pega o nome em PT-BR
                const ptbrName = item.LocalizedNames?.['PT-BR'];
                // Pega o UniqueName (pode ter @ ou não, ex: T7_2H_MACE@1 ou T7_2H_MACE)
                const uniqueName = item.UniqueName;

                if (ptbrName && uniqueName) {
                    // Chave: Nome em PT-BR normalizado
                    // Ex: "maça pesada do grão-mestre (.1)"
                    const nameKey = normalizeString(ptbrName); 
                    
                    // Valor: ID Base normalizado
                    const baseUniqueName = uniqueName.split('@')[0]; // Ex: T7_2H_MACE
                    const baseUniqueNameKey = normalizeString(baseUniqueName); // Ex: t7_2h_mace
                    
                    // Armazena (ex: "maça pesada...": "t7_2h_mace")
                    translationMap[nameKey] = baseUniqueNameKey;
                }
            });
            
            if (Object.keys(translationMap).length === 0) {
                throw new Error("Nenhum item traduzido (PT-BR) foi encontrado no items.json.");
            }

            return translationMap;
        }

        /**
         * Processa o CSV do Log do Baú (Passo 2, antigo 3).
         * @param {string} csvText - O conteúdo do arquivo CSV do baú.
         * @returns {Object} - Objeto { playerKey: { itemKey: quantity } }
         */
        function parseChestLog(csvText) {
            const depositsByPlayer = {}; // Estrutura: { playerKey: { itemKey_normalizado: quantity } }
            
            // Remove BOM e corrige quebras de linha
            const lines = csvText.trim().replace(/^\uFEFF/, '').split(/\r?\n/);

            if (lines.length <= 1) {
                throw new Error("O arquivo do baú está vazio ou tem apenas cabeçalhos.");
            }
            
            // Detecta automaticamente o delimitador do arquivo do baú (TAB, ; ou ,)
            const rawHeaderLine = lines[0].trim().replace(/^\uFEFF/, '').replace(/"/g, '');
            let delim = '\t';
            if (rawHeaderLine.indexOf('\t') >= 0) delim = '\t';
            else if (rawHeaderLine.indexOf(';') >= 0) delim = ';';
            else if (rawHeaderLine.indexOf(',') >= 0) delim = ',';
            const headers = rawHeaderLine.split(delim).map(h => h.trim());

            // Tenta encontrar índices de colunas por variações de nomes (PT-BR / EN)
            const findHeaderIndex = (candidates) => {
                const lower = headers.map(h => h.toLowerCase());
                for (const cand of candidates) {
                    const idx = lower.findIndex(h => h === cand || h.includes(cand));
                    if (idx !== -1) return idx;
                }
                return -1;
            };

            const nameIndex = findHeaderIndex(['jogador', 'player', 'nome', 'playername', 'looted_by__name']);
            const itemIndex = findHeaderIndex(['item', 'itens', 'itemname', 'item_name', 'nome item']);
            const quantityIndex = findHeaderIndex(['quantidade', 'quantity', 'amount', 'qty']);
            
            // Validação dos cabeçalhos
            if ([nameIndex, itemIndex, quantityIndex].includes(-1)) {
                console.error("Cabeçalhos do Log do Baú (detectados):", headers, "delim:", JSON.stringify(delim));
                throw new Error("Cabeçalhos do log do baú não encontrados (esperando Jogador/Item/Quantidade ou equivalentes). Verifique o separador/delimitador.");
            }

            // Itera pelas linhas de dados
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line) continue; // Pula linhas em branco
                
                const columns = line.split(delim);

                // Garante que a linha tem o número esperado de colunas
                if (columns.length < Math.max(nameIndex, itemIndex, quantityIndex) + 1) {
                    continue; 
                }
                
                // Limpa aspas (") dos dados
                const playerName = columns[nameIndex]?.replace(/"/g, '').trim();
                const itemNamePTBR = columns[itemIndex]?.replace(/"/g, '').trim(); // Nome em PT-BR (ex: "Picareta do Perito")
                const quantity = parseInt(columns[quantityIndex]?.replace(/"/g, ''), 10);
                
                // Pula a linha se o jogador ou o item não existirem (evita erro 'toLowerCase of undefined')
                if (!playerName || !itemNamePTBR || isNaN(quantity)) {
                    continue; 
                }

                // Considera apenas DEPÓSITOS (ignora retiradas)
                if (quantity <= 0) {
                    continue;
                }
                
                // --- Normalização e Tradução ---
                const playerKey = normalizeString(playerName);
                // Chave de busca: nome em PT-BR normalizado
                const itemNameKey = normalizeString(itemNamePTBR); // ex: "maça pesada do grão-mestre"
                
                // Traduz o nome PT-BR para o ID Base Normalizado
                // Ex: "maça pesada..." -> "t7_2h_mace"
                const itemKey = itemTranslationMap[itemNameKey];
                
                // Se o item do log do baú não foi encontrado no mapa, pulamos
                if (!itemKey) {
                    // console.warn(`Item não traduzido do log do baú: "${itemNamePTBR}" (Chave: ${itemNameKey})`);
                    continue;
                }
                
                // A chave final 'itemKey' já é o ID base normalizado (ex: "t7_2h_mace")

                // Inicializa o jogador se for a primeira vez
                if (!depositsByPlayer[playerKey]) {
                    depositsByPlayer[playerKey] = {};
                }
                
                // Inicializa o item para o jogador se for a primeira vez
                if (!depositsByPlayer[playerKey][itemKey]) {
                    depositsByPlayer[playerKey][itemKey] = 0;
                }
                
                // Soma a quantidade depositada
                depositsByPlayer[playerKey][itemKey] += quantity;
            }
            
            return depositsByPlayer;
        }

        // --- Helpers para múltiplos arquivos e merge ---
        /**
         * Lê um File como texto usando Promise
         * @param {File} file
         * @returns {Promise<string>}
         */
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('Falha ao ler o arquivo'));
                reader.readAsText(file);
            });
        }

        /**
         * Mescla os dados retornados por parseLootLog (apenas entradas novas) em lootData
         * @param {Object} parsedData
         */
        function mergeLootData(parsedData) {
            for (const playerKey in parsedData) {
                const player = parsedData[playerKey];
                if (!lootData[playerKey]) {
                    // Clona a estrutura do jogador
                    lootData[playerKey] = {
                        name: player.name,
                        guild: player.guild,
                        items: {}
                    };
                }

                for (const itemKey in player.items) {
                    const item = player.items[itemKey];
                    if (!lootData[playerKey].items[itemKey]) {
                        lootData[playerKey].items[itemKey] = { ...item };
                    } else {
                        // Soma quantidades (evita duplicar porque parse já filtrou)
                        lootData[playerKey].items[itemKey].lootedQuantity += item.lootedQuantity;
                        // Preserve itemId/name if missing
                        if (!lootData[playerKey].items[itemKey].itemId) lootData[playerKey].items[itemKey].itemId = item.itemId;
                        if (!lootData[playerKey].items[itemKey].name) lootData[playerKey].items[itemKey].name = item.name;
                    }
                }
            }
        }

        // --- FUNÇÕES DE RENDERIZAÇÃO E UI ---

        /**
         * Atualiza a UI com os dados de loot, aplicando os filtros.
         * Esta é a função principal de renderização.
         */
        function displayLootData() {
            // Proteções iniciais
            if (!playerLootContainer || !guildStatsItems || !guildStatsCard) return;
            if (!lootData || Object.keys(lootData).length === 0) return; // Não temos dados para mostrar
            
            // Limpa os resultados anteriores
            playerLootContainer.innerHTML = '';
            guildStatsItems.innerHTML = '';
            guildStatsCard.classList.add('hidden');
            
            // Pega os valores dos filtros
            const selectedGuild = guildFilter.value;
            const selectedDepositStatus = depositFilter.value;

            // Detecta itens perdidos antes de exibir
            detectLostItems();

            // Objeto para acumular estatísticas da guilda
            const guildStats = {
                totalItems: 0,
                items: {} // Estrutura: { itemKey: { ... } }
            };

            // 1. Itera sobre os dados de LOOT (lootData)
            for (const playerKey in lootData) {
                const player = lootData[playerKey];

                // 2. Aplica filtro de GUILDA
                const guildMatch = (selectedGuild === 'all' || player.guild === selectedGuild);
                if (!guildMatch) {
                    continue; // Pula este jogador
                }

                // Objeto para os itens filtrados deste jogador
                const filteredPlayerItems = {};
                let playerHasItemsToShow = false;

                // 3. Itera sobre os ITENS do jogador
                for (const itemKey in player.items) {
                    // itemKey é o ID base normalizado (ex: t7_2h_mace)
                    const item = player.items[itemKey];

                    // 4. Busca os dados de DEPÓSITO (do log do baú)
                    // (chestDepositData[playerKey] pode não existir)
                    // (chestDepositData[playerKey][itemKey] pode não existir)
                    const depositedQty = chestDepositData[playerKey]?.[itemKey] || 0;
                    
                    // Atualiza o item original no lootData (importante!)
                    item.depositedQuantity = depositedQty; 
                    
                    const lootedQty = item.lootedQuantity;

                    // 5. Aplica filtro de DEPÓSITO e itens perdidos
                    let depositMatch = false;
                    switch (selectedDepositStatus) {
                        case 'deposited':
                            depositMatch = (depositedQty > 0);
                            break;
                        case 'not-deposited':
                            depositMatch = (depositedQty === 0);
                            break;
                        case 'lost':
                            depositMatch = item.lostItem !== false;
                            break;
                        case 'all':
                        default:
                            depositMatch = true;
                            break;
                    }

                    if (depositMatch) {
                        // Se passou em todos os filtros, adiciona aos itens do jogador
                        filteredPlayerItems[itemKey] = item;
                        playerHasItemsToShow = true;
                        
                        // Adiciona também às estatísticas da guilda
                        if (!guildStats.items[itemKey]) {
                            // Se for a primeira vez, clona o item
                            guildStats.items[itemKey] = { ...item };
                        } else {
                            // Se já existe, apenas soma as quantidades
                            guildStats.items[itemKey].lootedQuantity += lootedQty;
                            guildStats.items[itemKey].depositedQuantity += depositedQty;
                        }
                        guildStats.totalItems += lootedQty;
                    }
                } // Fim do loop de itens

                // 6. Renderiza o Card do Jogador (se ele tiver itens que passaram nos filtros)
                if (playerHasItemsToShow) {
                    const playerCard = createPlayerCard(player.name, player.guild, filteredPlayerItems);
                    playerLootContainer.appendChild(playerCard);
                }
            } // Fim do loop de jogadores

            // 7. Renderiza o Card de Estatísticas da Guilda
            if (guildStats.totalItems > 0) {
                // Define o título do card
                let title = (selectedGuild === 'all') ? 'Todas as Guildas' : selectedGuild;
                
                // Formata o total de itens
                const totalText = guildStats.totalItems.toLocaleString('pt-BR');
                guildStatsTitle.textContent = `${title} (${totalText} itens looteados)`;

                // Renderiza os ícones dos itens da guilda
                for (const itemKey of Object.keys(guildStats.items).sort()) {
                    const item = guildStats.items[itemKey];
                    const itemIcon = createItemIcon(item);
                    guildStatsItems.appendChild(itemIcon);
                }
                guildStatsCard.classList.remove('hidden');
            }
        }
        
        /**
         * Cria e retorna um elemento HTML (card) para um jogador.
         * @param {string} playerName - Nome do jogador.
         * @param {string} playerGuild - Nome da guilda.
         * @param {Object} items - Objeto com os itens do jogador (já filtrados).
         * @returns {HTMLElement} - O elemento div do card.
         */
        function createPlayerCard(playerName, playerGuild, items) {
            const card = document.createElement('div');
            card.className = 'bg-slate-900 border border-slate-800 rounded-lg shadow-sm overflow-hidden card-hover-effect';

            // Cabeçalho do Card
            const header = document.createElement('div');
            // Modificado para flex
            header.className = 'p-4 border-b border-slate-800 flex justify-between items-center';
            
            // Container para Título e Guilda
            const titleContainer = document.createElement('div');

            const title = document.createElement('h3');
            title.className = 'text-lg font-semibold tracking-tight';
            title.textContent = playerName;
            
            const description = document.createElement('p');
            description.className = 'text-sm text-slate-400';
            description.textContent = `[${playerGuild}]`;
            
            titleContainer.appendChild(title);
            titleContainer.appendChild(description);
            
            // Botão Murderledger
            const ledgerLink = document.createElement('a');
            ledgerLink.href = `https://murderledger.albiononline2d.com/players/${playerName}/ledger?show_kills=0&show_assists=0`;
            ledgerLink.target = '_blank';
            ledgerLink.rel = 'noopener noreferrer';
            ledgerLink.textContent = 'Ledger'; // Texto mais curto
            // Estilo de botão "link" do ShadCN
            ledgerLink.className = 'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors h-9 px-3 py-1 bg-transparent text-slate-50 hover:bg-slate-800 hover:text-slate-50 shrink-0'; // shrink-0 para evitar quebra de linha

            // Container para os botões
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'flex gap-2 items-center';

            // Botão de fechar
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '&times;'; // × symbol
            closeButton.className = 'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors h-9 w-9 bg-transparent text-slate-400 hover:bg-red-900/20 hover:text-red-400';
            closeButton.title = 'Remover card';
            closeButton.onclick = () => card.remove();

            buttonsContainer.appendChild(ledgerLink);
            buttonsContainer.appendChild(closeButton);

            header.appendChild(titleContainer);
            header.appendChild(buttonsContainer);

            // Container dos Itens
            const itemsContainer = document.createElement('div');
            itemsContainer.className = 'p-4 flex flex-wrap gap-3'; // Flex-wrap para o grid

            // Ordena os itens (opcional, mas bom para consistência)
            const sortedItemKeys = Object.keys(items).sort();

            for (const itemKey of sortedItemKeys) {
                const item = items[itemKey];
                const itemIcon = createItemIcon(item);
                itemsContainer.appendChild(itemIcon);
            }

            card.appendChild(header);
            card.appendChild(itemsContainer);
            return card;
        }

        /**
         * Cria e retorna um elemento HTML (ícone) para um item.
         * @param {Object} item - O objeto do item (contendo itemId, name, lootedQuantity, depositedQuantity).
         * @returns {HTMLElement} - O elemento div do ícone (com tooltip).
         */
        function createItemIcon(item) {
            // Container principal (para tooltip)
            const iconWrapper = document.createElement('div');
            iconWrapper.className = 'tooltip';

            // O ícone em si
            const img = document.createElement('img');
            // Formato da URL: https://render.albiononline.com/v1/item/[ITEM_ID].png?quality=[QUALIDADE]
            
            // O baseUrl AGORA é o ID completo do item, incluindo o encantamento (ex: T6_2H_SKULLORB_HELL@3)
            const baseUrl = item.itemId;
            // O log de loot não nos dá a qualidade, então usamos 0 (Normal) como padrão para a URL.
            const quality = 0; 
            
            img.src = `https://render.albiononline.com/v1/item/${baseUrl}.png?quality=${quality}&size=100`;
            
            img.alt = item.name;
            // Estilo do ícone atualizado com indicadores
            let itemClass = 'w-16 h-16 rounded-md bg-slate-950 border-2 transition-all';
            
            // Só mostra indicadores de itens perdidos se o filtro estiver ativo
            if (depositFilter?.value === 'lost') {
                if (item.lostItem === 'lost') {
                    itemClass += ' border-red-600 shadow-red-900/50 shadow-lg';
                } else if (item.lostItem === 'found') {
                    itemClass += ' border-green-600 shadow-green-900/50 shadow-lg';
                }
            }
            img.className = itemClass;
            img.loading = 'lazy'; // Otimização

            // Contagem (ex: 5/10 ou apenas 10)
            const count = document.createElement('span');
            // Estilo da contagem atualizado
            count.className = 'absolute -bottom-2 -right-2 bg-slate-800 text-slate-50 text-xs font-bold px-1.5 py-0.5 rounded-full shadow-md border border-slate-700';
            
            // Tooltip (dica)
            const tooltipText = document.createElement('span');
            tooltipText.className = 'tooltiptext';

            // Lógica de Borda e Texto (Depositado vs. Looteado)
            const looted = item.lootedQuantity;
            const deposited = item.depositedQuantity;

            // Prepara informações do tooltip
            let tooltipContent = `${item.name}<br>Looteado: ${looted.toLocaleString('pt-BR')}`;
            
            // Adiciona informação de depósito se disponível
            if (Object.keys(chestDepositData).length > 0) {
                count.textContent = `${deposited.toLocaleString('pt-BR')}/${looted.toLocaleString('pt-BR')}`;
                tooltipContent += `<br>Depositado: ${deposited.toLocaleString('pt-BR')}`;
            } else {
                count.textContent = looted.toLocaleString('pt-BR');
            }

            // Adiciona informações de item perdido/encontrado
            if (item.lostItem === 'lost') {
                const nextPlayer = item.history.find(h => h.timestamp > item.history[0].timestamp)?.player;
                tooltipContent += '<br><br><span class="text-red-400">⚠️ Item Perdido</span>';
                if (nextPlayer) {
                    tooltipContent += `<br>Encontrado por: ${nextPlayer}`;
                }
            } else if (item.lostItem === 'found') {
                const previousPlayer = item.history.find(h => h.timestamp < item.history[item.history.length - 1].timestamp)?.player;
                tooltipContent += '<br><br><span class="text-green-400">✓ Item Encontrado</span>';
                if (previousPlayer) {
                    tooltipContent += `<br>Perdido por: ${previousPlayer}`;
                }
            }

            tooltipText.innerHTML = tooltipContent;

            // Define a borda do item com base no contexto
            let borderClass = ' border-slate-800'; // Borda padrão

            if (depositFilter?.value === 'lost') {
                // No filtro de itens perdidos, mostra as bordas de status perdido/encontrado
                if (item.lostItem === 'lost') {
                    borderClass = ' border-red-600 shadow-red-900/50 shadow-lg';
                } else if (item.lostItem === 'found') {
                    borderClass = ' border-green-600 shadow-green-900/50 shadow-lg';
                }
            } else if (Object.keys(chestDepositData).length > 0) {
                // Nos outros filtros, mostra status de depósito se disponível
                if (deposited >= looted) {
                    borderClass = ' border-green-600';
                } else if (deposited > 0) {
                    borderClass = ' border-yellow-500';
                }
            }

            // Aplica a classe de borda
            img.className += borderClass;

            iconWrapper.appendChild(img);
            iconWrapper.appendChild(count);
            iconWrapper.appendChild(tooltipText);
            
            return iconWrapper;
        }

        /**
         * Preenche o dropdown de filtro de guildas.
         * @param {Set} guilds - O Set de nomes de guildas.
         */
        function populateGuildFilter(guilds) {
            if (!guildFilter) return; // Proteção
            
            // Limpa opções antigas (exceto a primeira "Todas as Guildas")
            while (guildFilter.options.length > 1) {
                guildFilter.remove(1);
            }
            
            // Ordena as guildas alfabeticamente
            const sortedGuilds = [...guilds].sort((a, b) => a.localeCompare(b));
            
            sortedGuilds.forEach(guild => {
                const option = document.createElement('option');
                option.value = guild;
                option.textContent = guild;
                guildFilter.appendChild(option);
            });
        }
        
        // --- FUNÇÕES UTILITÁRIAS ---

        /**
         * Reseta a UI para um estado limpo, controlando a reativação dos inputs.
         * @param {string} step - 'loot', 'items', 'chest' ou 'null'
         */
        function resetUI(step = null) {
            if (loading) loading.classList.add('hidden');
            if (errorEl) errorEl.classList.add('hidden');
            if (successEl) successEl.classList.add('hidden');

            const lootLoaded = Object.keys(lootData).length > 0;
            
            // Habilita Passo 2 (Baú) se o Passo 1 (Loot) E o items.json (automático) estiverem concluídos
            const canLoadChest = lootLoaded && isItemMapReady;
            if (chestLogInput) chestLogInput.disabled = !canLoadChest;
            if (chestLogLabel) chestLogLabel.style.cursor = canLoadChest ? 'pointer' : 'not-allowed';
            if (chestLogLabel) chestLogLabel.classList.toggle('opacity-50', !canLoadChest);

            // Controla a visibilidade dos filtros e resultados
            if (step === 'loot') {
                // Limpa tudo a partir do Passo 2 (Baú)
                if (chestLogStatus) chestLogStatus.textContent = '';
                chestDepositData = {};
                
                if (depositFilterContainer) depositFilterContainer.classList.add('hidden');
                if (playerLootContainer) playerLootContainer.innerHTML = '';
                if (guildStatsCard) guildStatsCard.classList.add('hidden');
                // Mostra seção de filtros quando tiver dados de loot
                if (Object.keys(lootData).length > 0 && filtersSection) {
                    filtersSection.classList.remove('hidden');
                }
            } else if (step === 'items') {
                // Acontece após o fetch do items.json. Apenas re-habilita o botão do baú.
                // Não limpa mais nada.
            } else if (step === 'chest') {
                 // Apenas atualiza a UI, não limpa dados anteriores
                 if (depositFilterContainer) depositFilterContainer.classList.remove('hidden');
            }
            
            // Reseta o estado inicial (se nenhum passo foi dado)
            if (step === null) {
                if (lootLogStatus) lootLogStatus.textContent = '';
                if (chestLogStatus) chestLogStatus.textContent = '';
                lootData = {};
                chestDepositData = {};
                itemTranslationMap = {};
                guildList.clear();
                // Não reseta isItemMapReady, pois ele é carregado no início
                
                if (filtersSection) filtersSection.classList.add('hidden');
                if (depositFilterContainer) depositFilterContainer.classList.add('hidden');
                if (playerLootContainer) playerLootContainer.innerHTML = '';
                if (guildStatsCard) guildStatsCard.classList.add('hidden');
            }
            
            // Garante que o filtro de guilda apareça se o loot estiver carregado
            if (lootLoaded && filtersSection) {
                filtersSection.classList.remove('hidden');
            }
            
            // Garante que o filtro de depósito apareça se o baú estiver carregado
            if (Object.keys(chestDepositData).length > 0 && depositFilterContainer) {
                depositFilterContainer.classList.remove('hidden');
            }
        }

        /**
         * Mostra uma mensagem de carregamento na UI.
         * @param {string} message - A mensagem de carregamento.
         */
        function showLoading(message) {
            if (loading && loadingMsg) {
                loadingMsg.textContent = message;
                loading.classList.remove('hidden');
            }
            if (errorEl) errorEl.classList.add('hidden');
            if (successEl) successEl.classList.add('hidden');
        }

        /**
         * Mostra uma mensagem de erro na UI.
         * @param {string} message - A mensagem de erro.
         */
        function showError(message) {
            if (errorEl && errorElMsg) {
                errorElMsg.textContent = message;
                errorEl.classList.remove('hidden');
            }
            if (loading) loading.classList.add('hidden');
            if (successEl) successEl.classList.add('hidden');
        }

        /**
         * Mostra uma mensagem de sucesso na UI.
         * @param {string} message - A mensagem de sucesso.
         */
        function showSuccess(message) {
            if (successEl && successElMsg) {
                successElMsg.textContent = message;
                successEl.classList.remove('hidden');
            }
            if (loading) loading.classList.add('hidden');
            if (errorEl) errorEl.classList.add('hidden');
        }

        /**
         * Normaliza uma string (minúsculas, sem espaços extras) para usar como chave.
         * @param {string} str - A string para normalizar.
         * @returns {string} - A string normalizada.
         */
        function normalizeString(str) {
            if (typeof str !== 'string') return '';
            return str.toLowerCase().trim();
        }

        /**
         * Atualiza o sumário do loot com estatísticas
         */
        /**
         * Analisa o histórico de itens para detectar itens perdidos
         * Um item é considerado perdido se:
         * 1. Foi looteado por jogadores diferentes
         * 2. Em ordem cronológica (timestamp)
         * 3. Dentro de um intervalo razoável de tempo
         */
        function detectLostItems() {
            // Mapa para rastrear o histórico de cada item único
            const itemHistory = new Map();
            
            // Primeiro, vamos agrupar todos os loots pelo ID base do item
            for (const player of Object.values(lootData)) {
                for (const [itemKey, item] of Object.entries(player.items)) {
                    const baseItemId = item.uniqueName;
                    if (!itemHistory.has(baseItemId)) {
                        itemHistory.set(baseItemId, []);
                    }
                    // Adiciona todas as entradas do histórico deste item
                    itemHistory.get(baseItemId).push(...item.history.map(h => ({
                        ...h,
                        itemKey,
                        baseItemId
                    })));
                }
            }

            // Agora, para cada item, ordenamos por timestamp e procuramos padrões de perda
            for (const [baseItemId, history] of itemHistory.entries()) {
                // Ordena por timestamp
                history.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // Se o mesmo item aparece com players diferentes em sequência
                for (let i = 0; i < history.length - 1; i++) {
                    const current = history[i];
                    const next = history[i + 1];
                    
                    // Se são players diferentes e dentro de um intervalo de 5 minutos
                    const timeDiff = (new Date(next.timestamp) - new Date(current.timestamp)) / 1000 / 60; // em minutos
                    if (current.player !== next.player && timeDiff <= 5) {
                        // Marca o item como perdido no lootData
                        const currentPlayer = normalizeString(current.player);
                        const nextPlayer = normalizeString(next.player);
                        
                        // Marca o item como perdido para ambos os players
                        if (lootData[currentPlayer]?.items[current.itemKey]) {
                            lootData[currentPlayer].items[current.itemKey].lostItem = 'lost';
                        }
                        if (lootData[nextPlayer]?.items[next.itemKey]) {
                            lootData[nextPlayer].items[next.itemKey].lostItem = 'found';
                        }
                    }
                }
            }
        }

        function updateLootSummary() {
            const summarySection = document.getElementById('summarySection');
            const itemsSummary = document.getElementById('itemsSummary');
            const topLooterSummary = document.getElementById('topLooterSummary');
            const topGuildSummary = document.getElementById('topGuildSummary');

            if (!summarySection || !lootData) return;

            // Mostrar a seção
            summarySection.classList.remove('hidden');

            // 1. Total de itens looteados
            let totalItems = 0;
            for (const player of Object.values(lootData)) {
                for (const item of Object.values(player.items)) {
                    totalItems += item.lootedQuantity;
                }
            }
            itemsSummary.textContent = `${totalItems.toLocaleString()} itens`;

            // 2. Maior Looter
            let topLooter = { name: '', guild: '', total: 0 };
            for (const [playerKey, player] of Object.entries(lootData)) {
                let playerTotal = 0;
                for (const item of Object.values(player.items)) {
                    playerTotal += item.lootedQuantity;
                }
                if (playerTotal > topLooter.total) {
                    topLooter = {
                        name: player.name,
                        guild: player.guild,
                        total: playerTotal
                    };
                }
            }
            topLooterSummary.textContent = `${topLooter.name} [${topLooter.guild}] - ${topLooter.total.toLocaleString()} itens`;

            // 3. Guild com mais loot
            const guildTotals = new Map();
            const guildMembers = new Map();
            
            // Calcula totais por guild
            for (const player of Object.values(lootData)) {
                const guild = player.guild || 'Sem Guild';
                if (!guildTotals.has(guild)) {
                    guildTotals.set(guild, 0);
                    guildMembers.set(guild, new Set());
                }
                guildMembers.get(guild).add(player.name);
                
                for (const item of Object.values(player.items)) {
                    guildTotals.set(guild, guildTotals.get(guild) + item.lootedQuantity);
                }
            }

            // Encontra a guild com maior total
            let topGuild = { name: '', total: 0, members: 0 };
            for (const [guild, total] of guildTotals.entries()) {
                if (total > topGuild.total) {
                    topGuild = {
                        name: guild,
                        total: total,
                        members: guildMembers.get(guild).size
                    };
                }
            }
            
            topGuildSummary.textContent = `[${topGuild.name}] - ${topGuild.total.toLocaleString()} itens (${topGuild.members} membros)`;
        }

        // --- INICIALIZAÇÃO E EVENTOS ---
        // Espera o DOM carregar antes de inicializar elementos e adicionar listeners
        window.addEventListener('DOMContentLoaded', async () => {
            
            // 1. INICIALIZAÇÃO DOS ELEMENTOS DA DOM
            lootLogInput = document.getElementById('lootLogInput');
            lootLogStatus = document.getElementById('lootLogStatus');

            clearLootButton = document.getElementById('clearLootButton');

            // Removidos: itemsJsonInput, itemsJsonLabel, itemsJsonStatus

            chestLogInput = document.getElementById('chestLogInput');
            chestLogLabel = document.getElementById('chestLogLabel');
            chestLogStatus = document.getElementById('chestLogStatus');
            
            guildFilter = document.getElementById('guildFilter');
            depositFilter = document.getElementById('depositFilter');
            depositFilterContainer = document.getElementById('depositFilterContainer');
            filtersSection = document.getElementById('filtersSection');
            
            loading = document.getElementById('loading');
            loadingMsg = document.getElementById('loading-message');
            errorEl = document.getElementById('error');
            errorElMsg = document.getElementById('error-message');
            successEl = document.getElementById('success');
            successElMsg = document.getElementById('success-message');

            guildStatsCard = document.getElementById('guildStatsCard');
            guildStatsTitle = document.getElementById('guildStatsTitle');
            guildStatsItems = document.getElementById('guildStatsItems');
            playerLootContainer = document.getElementById('playerLootContainer');
            
            // 2. CARREGAMENTO AUTOMÁTICO DO ITEMS.JSON
            await loadItemsJsonFromUrl();

            // 3. ATRIBUIÇÃO DOS EVENT LISTENERS
            
            // Event listener para o input do Log de Loot (Passo 1) - suporta múltiplos arquivos e merge incremental
            if (lootLogInput) {
                lootLogInput.addEventListener('change', async (event) => {
                    const files = Array.from(event.target.files || []);
                    if (files.length === 0) return;

                    // Não resetamos os dados existentes - fazemos merge incremental
                    lootLogStatus.textContent = `Carregando ${files.length} arquivo(s)...`;

                    let totalAdded = 0;
                    let totalDuplicates = 0;

                    for (const file of files) {
                        try {
                            showLoading(`Processando ${file.name}...`);
                            const csvText = await readFileAsText(file);
                            const { data, guilds, entriesAdded, duplicateEntries, totalEntries } = parseLootLog(csvText, lootEntrySet);
                            
                            totalDuplicates += duplicateEntries;

                            // Mescla os dados retornados (apenas entradas novas)
                            mergeLootData(data);

                            // Atualiza lista de guildas
                            for (const g of guilds) guildList.add(g);

                            totalAdded += (entriesAdded || 0);
                            showSuccess(`Arquivo "${file.name}" processado. ${entriesAdded} entradas novas adicionadas.`);
                            lootLogStatus.textContent = `Carregado: ${file.name} (+${entriesAdded})`;
                        } catch (err) {
                            // Se o arquivo não trouxe dados novos, avisamos, mas não limpamos tudo
                            showError(`Erro ao processar "${file.name}": ${err.message}`);
                            console.error("Stack:", err.stack);
                            // continue com os próximos arquivos
                        }
                    }

                    // Atualiza UI e resultados na ordem correta
                    populateGuildFilter(guildList);
                    if (filtersSection) filtersSection.classList.remove('hidden');
                    
                    // Garante que os filtros estejam com valores padrão
                    if (guildFilter) guildFilter.value = 'all';
                    if (depositFilter) depositFilter.value = 'all';
                    
                    // Habilita próximos passos
                    resetUI('loot'); // Habilita o Passo 2 (Baú) se aplicável
                    
                    // Força a exibição dos dados após configurar tudo
                    displayLootData();

                    // Atualiza o sumário
                    updateLootSummary();

                    // Limpa o input para permitir re-seleção dos mesmos arquivos
                    try { if (lootLogInput) lootLogInput.value = ''; } catch (e) { /* ignore */ }

                    // Mensagem resumida
                    lootLogStatus.textContent = `Processamento concluído. Total de entradas novas: ${totalAdded.toLocaleString('pt-BR')}`;
                });
            }

            // Botão limpar (reseta todos os dados carregados)
            if (clearLootButton) {
                clearLootButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    lootEntrySet.clear();
                    resetUI(null);
                    if (lootLogInput) lootLogInput.value = '';
                    showSuccess('Dados de loot e depósitos limpos.');
                });
            }

            // Removido: Event listener para o input do items.json
            
            // Event listener para o input do Log do Baú (Passo 2, antigo 3)
            if (chestLogInput) {
                chestLogInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    resetUI('chest'); // Reseta a partir do passo 2
                    chestLogStatus.textContent = `Carregando: ${file.name}`;
                    showLoading("Processando Log do Baú...");
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const csvText = e.target.result;
                            chestDepositData = parseChestLog(csvText);

                            showSuccess(`Log do Baú "${file.name}" carregado! ${Object.keys(chestDepositData).length} jogadores encontrados no log do baú.`);
                            chestLogStatus.textContent = `Carregado: ${file.name}`;

                            resetUI('chest'); // Habilita o filtro de depósito
                            displayLootData(); 
                        } catch (err) {
                            showError(`Erro ao processar o log do baú: ${err.message}`);
                            console.error("Stack:", err.stack);
                            resetUI('items'); // Reverte para o estado pós-passo 1
                        }
                    };
                    reader.onerror = () => {
                        showError('Falha ao ler o arquivo do baú.');
                        resetUI('items');
                    };
                    reader.readAsText(file);
                });
            }
            
            // Event listeners para os filtros
            if (guildFilter) {
                guildFilter.addEventListener('change', displayLootData);
            }
            if (depositFilter) {
                depositFilter.addEventListener('change', displayLootData);
            }
        });

    </script>
</body>
</html>



